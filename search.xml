<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AFL-基础</title>
      <link href="/2021/08/01/afl-basis/"/>
      <url>/2021/08/01/afl-basis/</url>
      
        <content type="html"><![CDATA[<h1>AFL简介</h1><div class="note info simple"><p>模糊测试（<a href="https://en.wikipedia.org/wiki/Fuzzing">Fuzzing</a>）是一种软件测试技术，通过特定的方式自动化生成测试用例来挖掘程序的潜在漏洞。其中基于变异（Mutation-based）的模糊测试器（例如AFL，libfuzzer，honggfuzz）由于其运行快速，无需具备程序先验知识等特性，目前被广泛认为是较为主流的Fuzzing技术。</p></div><div class="tabs" id="afl-info"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#afl-info-1">Abstract</button></li><li class="tab"><button type="button" data-href="#afl-info-2">Figure</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="afl-info-1"><p>AFL（<a href="https://github.com/google/AFL">American Fuzzy Lop</a>）是由 Michal Zalewski（Google）开发的一款基于覆盖导向（Coverage-guided）的模糊测试器。通过记录测试输入的代码覆盖率（Edge coverage of CFG），AFL能够调整加入种子集（Corpus）的文件以提高总体的边覆盖率，进而增加发现程序漏洞的概率。其工作流程如下：</p><ol><li><p>预先对待测程序进行代码插桩（instrument），用于在程序执行过程中收集边覆盖信息。</p></li><li><p>Corpus中选择一些种子文件，按一定的策略对种子文件进行变异操作。</p></li><li><p>将变异后的文件作为测试用例执行待测程序，如果执行中覆盖到了新边（或已覆盖边的执行次数发生改变），则将其加入种子集用于之后进一步的变异，这样的文件称之为 interesting file。</p></li><li><p>上述的过程重复循环执行，期间触发crash的文件会被记录下来。Fuzzing结束后基于这些文件，开发者可以定位并修复相应的漏洞。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="afl-info-2"><div class="justified-gallery"><p><img src="https://i.loli.net/2021/08/06/VnKfiarlWQFT4Np.png" alt=""><br><img src="https://i.loli.net/2021/08/06/haBiq2OEyPs3puW.png" alt=""></p>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h1>Fuzzing with AFL</h1><div class="note primary flat"><p>AFL的使用步骤：1.待测程序插桩   2.构建语料库   3.执行Fuzzing</p></div><h2 id="Instrument">Instrument</h2><p>AFL提供了多种程序插桩方式，主要是在编译（llvm）或者汇编（as）阶段通过<code>afl-clang/afl-gcc</code>进行插桩，同时也提供了在程序执行阶段的动态插桩方式（QEMU）。插桩过程会在每个程序基本块中插入探针，从而实现程序分支覆盖信息的收集。下面以编译<a href="https://www.gnu.org/software/binutils/">GNU Binutils</a>为例，分别用<code>afl-gcc</code>和<code>afl-clang</code>进行插桩：</p><div class="note primary disabled"><p>常用Fuzzing测试集：<a href="https://github.com/google/fuzzbench">Google-fuzzbench</a>, <a href="https://hexhive.epfl.ch/magma/">Magma</a></p></div><br><div class="tabs" id="afl-instrument"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#afl-instrument-1">afl-gcc</button></li><li class="tab"><button type="button" data-href="#afl-instrument-2">afl-clang</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="afl-instrument-1"><p><code>afl-gcc/afl-g++</code>作为<code>gcc/g++</code>的wrapper，其用法完全一致。前者会将接收到的参数传递给后者，编译时只需将编译器设置为<code>afl-gcc/afl-g++</code>即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># make AFL</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/google/AFL.git &amp;&amp; <span class="built_in">cd</span> AFL</span><br><span class="line">$ make all</span><br><span class="line"></span><br><span class="line"><span class="comment"># download binutils-2.37</span></span><br><span class="line">$ wget https://ftp.gnu.org/gnu/binutils/binutils-2.37.tar.gz</span><br><span class="line">$ tar -xvf binutils-2.37.tar.gz &amp;&amp; <span class="built_in">cd</span> binutils-2.37</span><br><span class="line"></span><br><span class="line"><span class="comment"># add AFL to PATH and set C compiler</span></span><br><span class="line">$ <span class="built_in">export</span> CC=afl-gcc CXX=afl-g++</span><br><span class="line"></span><br><span class="line"><span class="comment"># make binutils</span></span><br><span class="line">$ ./configure --prefix=/path/to/intall --disable-shared</span><br><span class="line">$ make -j &amp;&amp; make install</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="afl-instrument-2"><p>AFL中的LLVM_Mode基于<code>afl-clang-fast</code>，其用法和原理与<code>afl-gcc</code>相似。</p><blockquote><p>编译<code>afl-clang-fast</code>时，所用<code>clang</code>版本需要与<code>llvm-config</code>显示的版本所对应（以8.0为例）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># change the llvm &amp; clang verison, install if not exist</span></span><br><span class="line">$ <span class="built_in">export</span> PATH=/usr/lib/llvm-8/bin:<span class="variable">$PATH</span></span><br><span class="line">$ sudo update-alternatives --config clang</span><br><span class="line"></span><br><span class="line"><span class="comment"># link the llvm-config to llvm-8</span></span><br><span class="line">$ <span class="built_in">cd</span> /usr/bin</span><br><span class="line">$ sudo ln -snf ../lib/llvm-8/bin/llvm-config llvm-config</span><br></pre></td></tr></table></figure><blockquote><p>编译<code>afl-clang-fast</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># make AFL clang</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/google/AFL.git</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> AFL &amp;&amp; make all</span><br><span class="line">$ <span class="built_in">cd</span> llvm_mode &amp;&amp; make all</span><br></pre></td></tr></table></figure><blockquote><p>编译待测程序前，需要设置<code>AFL_PATH</code>，使编译器可以找到<code>afl-llvm-rt.o</code>和<code>afl-llvm-pass.so</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set AFL_PATH</span></span><br><span class="line">$ <span class="built_in">export</span> AFL_PATH=/afl/root/path</span><br><span class="line"></span><br><span class="line"><span class="comment"># add AFL to PATH and set C compiler</span></span><br><span class="line">$ <span class="built_in">export</span> CC=afl-clang-fast CXX=afl-clang-fast++</span><br><span class="line"></span><br><span class="line"><span class="comment"># make binutils</span></span><br><span class="line">$ ./configure --prefix=/path/to/intall --disable-shared</span><br><span class="line">$ make -j &amp;&amp; make install</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="Corpus">Corpus</h2><p>AFL需要初始的种子文件作为Fuzzing的起点，这些输入甚至可以是毫无意义的数据类型。但是高质量的语料库很大程度上决定了Fuzzing的效率和结果的覆盖率，进而加大了触发异常的概率。</p><h3 id="Seed-Selection">Seed Selection</h3><p>AFL种子选择条件：1.有效的输入   2.避免过大的文件（AFL文档中<a href="https://github.com/google/AFL/blob/master/docs/perf_tips.txt">perf_tips.txt</a>有具体说明）</p><ul><li>项目自身提供的测试用例</li><li>afl源码<a href="https://github.com/google/AFL/tree/master/testcases">testcases</a>目录下提供的测试用例</li><li>开源语料库：<a href="https://lcamtuf.coredump.cx/afl/demo/">afl-image-sets</a>, <a href="https://github.com/google/fuzzer-test-suite">goolge-fts</a>, <a href="https://github.com/MozillaSecurity/fuzzdata">fuzzdata</a>, <a href="https://gitlab.anu.edu.au/lunar/moonlight">moonlight</a></li></ul><h3 id="Corpus-Distillation">Corpus Distillation</h3><p>现成的语料库往往存在大量文件，需要对其进行精简，该过程叫做语料库蒸馏（Corpus Distillation）。这里我们介绍用AFL自带的两个程序<code>afl-cmin</code>&amp;<code>afl-tmin</code>来完成，其他蒸馏的方式可参考<a href="https://arxiv.org/abs/1905.13055">Corpus Distillation Evaluation</a>。</p><ol><li><p>afl-cmin: 移除执行相同代码的种子文件</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-cmin -i input_dir -o output_dir -- /path/to/program [params] @@</span><br></pre></td></tr></table></figure></li><li><p>afl-tmin: 缩小单个种子文件的大小</p><blockquote><p>instrumented mode [default] / crash mode [-x]: 删除导致程序异常结束的文件</p></blockquote> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-tmin -i input_file -o output_file -- /path/to/program [params] @@</span><br></pre></td></tr></table></figure></li></ol><h2 id="Fuzzing">Fuzzing</h2><p>AFL以初始语料库作为输入，输出为Fuzzing过程中产生的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预先设置（root），防止将core dump误报为timeout</span></span><br><span class="line"><span class="built_in">echo</span> core &gt;/proc/sys/kernel/core_pattern</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用@@代替输入文件位置</span></span><br><span class="line">$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program [params] @@</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出在findings_dir/queue/路径下</span></span><br></pre></td></tr></table></figure><h3 id="并行执行">并行执行</h3><div class="note primary disabled"><p>主fuzzer执行确定性测试（deterministic），从fuzzer执行完全随机变异（havoc）。</p></div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># start master fuzzer</span></span><br><span class="line">$ afl-fuzz -i testcase_dir -o sync_dir -M fuzzer1 -- /path/to/program [params] @@</span><br><span class="line"></span><br><span class="line"><span class="comment"># start multiple slave fuzzers</span></span><br><span class="line">$ afl-fuzz -i testcase_dir -o sync_dir -S fuzzer2 -- /path/to/program [params] @@</span><br><span class="line">$ afl-fuzz -i testcase_dir -o sync_dir -S fuzzer3 -- /path/to/program [params] @@</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><h3 id="AFL执行状态窗口">AFL执行状态窗口</h3><div class="tabs" id="afl-state"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#afl-state-1">State Window</button></li><li class="tab"><button type="button" data-href="#afl-state-2">Illustration</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="afl-state-1"><p><img src="https://i.loli.net/2021/08/07/QlDANhmJvKGsW76.png" alt=""></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="afl-state-2"><ul><li>process timing: AFL运行时长、以及距离最近发现的路径、崩溃和挂起经过的时间</li><li>overall results: 当前Fuzzing的输出结果（包括<code>/crashes/</code>, <code>/hangs/</code>, <code>/queue/</code>三个路径下的文件）</li><li>cycle progress: 输入队列（Queue）的执行状态</li><li>map coverage: 待测程序的代码覆盖范围（以bitmap保存所有边）</li><li>stage process: AFL当前文件变异策略、执行次数和速度</li><li>findings in depth: 执行路径，异常和超时的信息</li><li>fuzzing strategy yields: 变异策略行为与结果的详细记录</li><li>path geometry: 以覆盖的执行路径信息</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><hr><h1>参考资料</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/43432370">Brief Surveys on Fuzz Testing</a></li><li><a href="https://lcamtuf.coredump.cx/afl/">American Fuzzy Lop</a></li><li><a href="https://www.freebuf.com/articles/system/191543.html">AFL漏洞挖掘技术漫谈</a></li><li><a href="https://kiprey.github.io/2020/07/AFL-LLVM-Mode/#4-afl-llvm-pass-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">AFL的LLVM_Mode</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Research </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Fuzzing </tag>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
